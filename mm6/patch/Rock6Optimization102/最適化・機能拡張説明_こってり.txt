====================================================================================================

　やたらくどい私が贈る、やたら長ったらしく、その割にやたら薄い解説。誤字脱字多し。

　最適化や容量の項目において現れる、具体的な値については、
　測定状況や、測定後のプログラム変更により変化しますので、目安となっております。

　●以下の説明において使う用語
　　任意バンク:どこに配置してもよいプログラムを配置する空きプログラムバンク。
　　　　　　　 今回はバンク0Dに配置してある。他のバンクに移動してもよいが、
　　　　　　　 同じバンク内のサブルーチンをjsrしていることがあるので、
　　　　　　　 サブルーチンをバラして移動すると事故る。
　　固定バンク:ゲームの仕様上、常時E000-FFFFに割り当てられている、プログラムバンク3F。
　　　　　　　 その末端にある、とても貴重な空き容量を利用する。

■■■■■■■■最適化■■■■■■■■
●地形判定最適化その１(SW_OptimizeTerrain)
　最適化:中(例:ロックマンの足元の１点判定($388751)　542=>289)
　副作用:中
　容量　:任意バンク(0xAC) 固定バンク(0xA7)
　競合　:SW_OptimizeTerrain2

　ファミコンロックマンシリーズは、ゲーム中でもROM上だけにマップを持っており、
　そして、そのマップは縦・横いくつずつといった単位で、数回圧縮されています。
　データが必要になる度に、ステージデータのあるプログラムバンクに切り替えて、
　圧縮をほどくようにデータアクセスしなければならないので、それなりに負荷がかかります。

　この設定を有効にすると、ステージに入った時に、
　ステージ全体を拡張RAMにロードすることにより最適化を試みます。
　これにより、上記のアクセスの手間の内、バンクを切り替える部分が省略できるようになります。
　また、いつでもメモリアドレスの固定位置にマップデータが存在することにより
　少々速いコードを利用できるため、それに置き換えます。

　副作用として、改造に用いる場合は、ステージ内で記録したセーブステートをそのままロードできず、
　書き換える度にロード後に一度やられなければならないという問題が生じます。
　また、こちらはあまりデバッグしていないという、とてもしょーもない問題を抱えています。

●地形判定最適化その２(SW_OptimizeTerrain2)
　最適化:大(例:ロックマンの足元の１点判定($388751)　542=>137)
　　　　 　(例２:横スクロール時のName Table転送(3EDD36からStep Out)4280=>1176)
　副作用:大
　容量　:任意バンク(0x4F4) 固定バンク(0x48)
　競合　:SW_OptimizeTerrain

　大体前項の続きのような話になりますが、この設定を有効にすると、
　ステージに入った時と、ルーム間スクロールする時に、１部屋分ずつマップをロードします。
　ただ単にロードするだけではなく、16x16タイル単位にメモリ上に展開まで行います。
　これにより、データアクセスの処理をとても簡潔に記述できるようになり、
　処理時間も大きく低減することが可能です。
　更に、横にスクロールするときの、縦１列分のName Tableへの転送データのセットアップに
　原作では甚大な時間がかかっているのですが、(※1フレームが約30000サイクルの所、4280程度かかる)
　この処理も簡潔に記述できるようになるため、大きく処理時間を削減できます。

　非常に大きな効果をもたらすこの項目ですが、その分、副作用も大きいです。
　目立つのが、ルーム間スクロールする度にロード時間がかかるようになる点です。
　ロード時間は、移動先ルームの大きさに比例して大きくなります。最適化という目的に反しています。
　また、ブロックを破壊した時など、地形が変化するときの処理が、原作よりも少々重くなります。

　改造に使う場合は更に幾つかの副作用を考慮する必要があります。

　まず、前項と同じように、セーブステートがそのままロードできなくなります。
　但し、こちらは、ルーム間スクロールする事でロードし直せる可能性があります。
　ただ、16x16タイルの属性を変更した場合は、やはり一度やられないと上手くいきません。

　さらに、幾つかのシーン、具体的には、ケンタウロスマンステージの天井水の属性、
　エックスステージ２の落下床、ボスラッシュの最後の脱出カプセル出現において、
　専用の処理を設けて対処しています。つまり、原作にはないややこしい仕様が増えることになります。

　最も面倒な副作用ですが、ロックマン６では、マップの部屋の番号やサイズといった概念に乏しく、
　読み込む部屋のサイズを原作の情報からだけでは特定が困難です。その為、マニュアルで指定してあります。
　従って、マップを改造した場合、その部屋情報を新たに作り直さなければなりません。
　その為には、最適化適用後のバイナリを、バイナリエディタで覗き、以下のバイト列を検索します。
00 00 00 00 00 00 01 02 02 02 02 02 03 04
　これは、ブリザードマンステージの部屋の情報です。
　最初に00が６個並んでいます。これは、最初の部屋が横６画面分の部屋である事を表します。
　以下同様に、01が１個（１画面）、02が５個（５画面）、03と04が１個（１画面）ずつとなっており、
　実際にブリザードマンステージの構成と対応していることがわかると思います。
　改造したマップに応じたデータを入力すれば正しく動く(部屋がロードされる)ようになります。
　検索でヒットしたアドレスから、0x20ずつ１６ステージ分のデータが格納されています。
　入力が正しくないと、横スクロールする部屋において、突然地形が途切れたりします。

　細かい点では、武器取得画面のマップが、上半分が空間、下半分が壁という形に固定されるといった問題も。
（それは、そちらのほうが良いような気もするが）

●衝突判定最適化(SW_OptimizeCollision)
　最適化:中(例:ある同一条件下で100fの間に判定処理にかかった時間　340871=>180602)
　副作用:無
　容量　:固定バンク(0x3D)

　オブジェクト間の衝突判定を最適化します。
　衝突判定は、自機と敵の接触や、自機の武器と敵の接触等に広く利用されています。
　この最適化は、オブジェクト間に衝突が起こるのは稀なケースであるという特徴を利用し、
　雑な判定で当たり得ない時を低コストで除外し、
　当たりそうな時は改めて正確に処理を行うという手法を利用します。
　具体的には、X座標のドット単位だけを（画面単位を考慮せずに）先に処理し、当たらなければ即除外、
　続いて、Y座標でも同じことを行い、衝突する可能性があるときだけ正確に処理を行います。

　原作では、１つの衝突判定で最低143サイクルほどかかってしまいますが、
　この最適化では、X座標で当たり得ない時は、最低66サイクル、
　Xが近い時でもY座標が遠ければ、120サイクル程度で処理を切り上げます。
　しかし、X,Yとも近い時にはかなり大きなペナルティを負います。
　そのため、多くのオブジェクトが一箇所に密集しているという状況においては、逆効果です。

　平均すればそこそこの最適化効果があると思います。
　副作用は無いと思いますが、私のプログラムミスがあったらその限りではありません。

●スプライトセットアップ処理最適化(SW_OptimizeObjectSpriteProc)
　最適化:小(例:ある同一条件下で100fの間にスプライトセットアップにかかった時間　883889=>772191)
　副作用:微
　容量　:任意バンク(0x11)

　幾つかの方法でスプライトセットアップ処理を最適化します。
　スプライトセットアップ時に、偶数・奇数フレームで、昇順・降順のテーブルを作る処理があります。
　結構時間がかかるので、ゲームブート時に作ってしまい、それを参照させる形にすることで最適化出来ます。
　また、スプライトセットアップの最内周を、涙ぐましくフラグ上げ下ろしすらケチって
　１サイクル単位で最適化します。その他チマチマ削ります。

　一応、副作用があり、原作では右向きオブジェクトが画面左端に居ると、
　姿は見えないが存在しているという状態になりますが、この状態の時、姿が見える状態になります。
　また、画面上端で上下逆向きでも、同じことが起きます。
　さらに、原作では右向きのオブジェクトが上下にはみ出た時に逆側に見えてしまう問題がありますが
　その問題が起きなくなります。

●音楽処理の最適化(SW_OptimizeSoundProcess)
　最適化:小(例:ウインドマンステージBGMを１周強(3750f)流して、1f平均3233.4=>3057.4)
　副作用:微
　容量　:固定バンク(0x2C)[スイッチ1,2指定時] (0x9F)[スイッチ3指定時]
　設定値:0,1,2,3が設定可能

　サウンドドライバに、幾つかの最適化処理を施します。
（１）乗算処理のadc #$00をincに置き換え
（２）叩くレジスタを指定するためにテーブルを利用
（３）モジュレーションのアドレス算出の簡略化
（４）効果音発音時のメモリクリア処理のループ展開

　色々やっている割には効果が乏しいです。悲しい。
　改造を考えると、モジュレーション番号として0x80以上が利用できなくなるという副作用があります。
（プログラムを調整すれば回避できます）
　それ以上に、固定バンクに容量（テーブル等）をとってしまう事が問題だと思います。
　スイッチ3は単なるループ展開のために固定バンクに大容量を割かなければならず、オススメできません。
　スイッチ1,2は同じ容量を利用します。制作の途中では、
　スイッチ1より、スイッチ2の方に多少大きな容量を取ってしまう予定だったのですが、
　スイッチ1でも利用するテーブルの中にプログラムを埋め込むことで、同容量で良くなりました。
　従って、スイッチ1にするメリットは全くありません。スイッチ2を使うのが良いでしょう。
　実は、サウンドドライバの譜面の位置にテーブルを確保することで、
　貴重な固定バンクにデータを置かずにすみます。

●ゲームパッド取得処理の最適化(SW_OptimizeGamepad)
　最適化:中(1fにつき511=>138)
　副作用:小
　容量　:固定バンク(0x48)

　単にループ展開しただけです。固定バンクに微妙に痛い容量が必要になりますが、
　毎フレーム確実に効果が出る値としてはまあまあだと思います。
　副作用として、２コンと拡張入力端子に接続されたコントローラーの入力を受け付けなくなります。
　２コンはともかく、連射パッドなどが使えなくなるので実機で動かす際には問題になりそうです。

■■■■■■■■中途半端■■■■■■■■
　以下の３つはまとめて0か1を指定する必要がある。
　プログラム上そうなっただけであり、本来は別個に指定できるべきであった。

●左端にオブジェクトがある時30fps化するバグの修正(SW_FixSpriteGlitch_LEdge)
　負荷　:微
　副作用:無
　容量　:固定バンク(0x1B)
　必要　:SW_SynchronizeAnimation,SW_OptimizeDMASrcFilling(,SW_FixSpriteGlitch_Gauge)

　まず恐らくあまり知られていないこのバグの説明を。
　そのフレームで最初にスプライトセットアップされるオブジェクトが、
　右向きで画面の左端に居る、存在しているが姿が見えない状態になった時に発生します。

　ヤマトマンステージ最初のシガラキーを使うと再現しやすいです。
　シガラキー２体目まで倒して、アイテムが出現したら消えるまで待ち、
　画面内にオブジェクトの無い状態にします。
　その状態にしたら、左に少しずつ戻り、１体目のシガラキーを発生させ
　姿が見えなくなるまで右に少しずつ移動すると、この現象が発生します。
　姿の見えなくなったシガラキーの発射する弾をよく見ると、30fps化していることが分かります。
　アニメーション処理も遅くなっており、パワーロックマンのショットや、
　ジェットロックマンのホバリングエフェクトが通常と異なる状態になります。

　事象としてあまりに稀な上、起こってもすぐに解除され、また、症状としても軽微であるため
　正直、対処する必要性を感じません。
　しかも、SW_OptimizeObjectSpriteProcのスイッチを有効にすると（まず）起こらなくなります。
　尚、両方のスイッチを有効にしても問題は起こりません。

●アニメーション処理の同期化(SW_SynchronizeAnimation)
　負荷　:中増
　副作用:無
　容量　:無
　必要　:SW_FixSpriteGlitch_LEdge,SW_OptimizeDMASrcFilling(,SW_FixSpriteGlitch_Gauge)

　このゲームは、スプライトセットアップ処理に合わせて、アニメーション処理を行う仕様です。
　ところが、スプライトセットアップの最中に、スプライトが足りなくなると、
　処理を行っていたオブジェクトから先のアニメーション処理が行われなくなる仕様になっています。
　奇しくも、ロックマン２と全く同じ状態になっています。
　ロックマン２は、ノックバック２倍バグ等の原因になりましたが、このゲームでは大きな問題は起きません。
　しかし、ロックマン３・４・５と異なり、自機やボスのティウン爆発のタイミングが
　爆発同士でばらばらになってしまう問題を引き起こしています。
　このスイッチを有効にすると、必ず全てのアニメーション処理を行う様に変更されます。
　それにより、ティウン爆発のタイミングが全ての爆発で一致するようになります。

　余談ですが、ティウン爆発は、全て同じタイミングで
　アニメーションが始まるように工夫されてコーディングされています。にも関わらず、
　アニメーション処理の方の仕様のせいでバラバラなタイミングになっています。残念仕様。

　本来ならスキップされる処理を行うように変更するため、負荷が多少増えてしまいます。
　……しかも、スプライト・オブジェクトが多い時に。

●DMAソースのクリア処理の最適化(SW_OptimizeDMASrcFilling)
　最適化:小(538～-60)
　副作用:無
　容量　:固定バンク(0x46)
　必要　:SW_FixSpriteGlitch_LEdge,SW_SynchronizeAnimation(,SW_FixSpriteGlitch_Gauge)

　スプライト処理のお約束の処理として、スプライトを未使用の状態に埋める処理があります。
　ループ展開することにより、その処理の速度を上げます。
　しかし、まずクリアしてからスプライト処理を行う５までとは違い、
　スプライト処理を終了後、余ったスプライトをクリアするという方式が取られているため、
　それほど効果が上がりません。
　それどころが、スプライトの余りが少ない時はオーバーヘッドが生じる分、僅かに遅くなってしまいます。
　悪いことに、画面内にオブジェクトが大量に存在し、スプライトが大量に利用されているという
　処理落ちがしやすそうな状態で重くなるという困った仕様。

■■■■■■■■機能追加■■■■■■■■
●ロックマンのスライディングの修正(SW_FixRockMove_Sliding)
　負荷　:微～中増
　副作用:小
　容量　:固定バンク(0x4D) バンク38(0x2F)

　スライディングに関する挙動を、５以前の仕様に近づけます。
（１）一歩前が空いている時のみ、スライディング可能に変更
（２）スライディングジャンプを可能に変更
（３）地面との接地判定を広くし、崖から少し大きめにはみ出しても落ち始めない様に変更
（４）スライディング終了後、「棒立ち」ではなく、「歩行」に移行する様に変更
（５）見かけが浮いて見えるため、スプライト定義で少し下げるように変更

　また、ワイリーステージ２で見られる、狭い通路の１歩先の溝に立ち上がれるように処理が追加されます。
　この際に、ちょっと「クッ」と移動してしまいます。横にスクロールする場所だと少々目立ちます。
　この、１歩先の溝に立ち上がる処理は、５以前のロックマンには存在しません。

　５以前の仕様と同様ですが、トゲに刺さりやすくなる副作用もあります。
　トマホークマンステージの最初のマップ等。

　ロックマンのハンドラ内で地形を読みに行く機会が増えるフレームが有るため、
　そういったフレームには負荷が増大します。
　スライディングを始めるフレームや、足先を壁にぶつけている間等。

　何故かバンク38の末端を利用しています。深い意味はありません。

●ロックマンの地形との接触処理の修正(SW_FixRockMove_Terrain)
　負荷　:中増
　副作用:小
　容量　:固定バンク(0x23)

　ロックマン５までと違い、ロックマン６は地形の角の部分に斜めにあたった時、
　ぬるっと移動して、足場から弾かれて落とされる事があります。
　５までは、X方向、Y方向を個別に、動かして、地形を読み、押し戻す、といった手順をしてきたのに対し、
　６では、X方向Y方向を同時に動かしてしまい、
　よくわからない順番でロックマンの近傍の地形を読みに行き
　押し戻し処理を行っていることが原因のようです。
　この現象は、Y速度が大きくなっていると起きやすく、プラントマンステージのバネで
　大きく跳ねた後着地するときに良く起きる事を、経験的に知っている方が多いと思います。

　このスイッチを有効にすると、ロックマンの移動処理を大きく見直し、
　まず、Y方向にだけ移動し、Y方向の地形を読みに行き、壁に触れていたら押し戻し、
　続いて、X方向でも同じことをする、という順番に変更されます。
　これにより、５までに近い挙動になります。

　副作用ですが、当然ながら、原作とは違う操作感に違和感を感じることもあるかもしれません。

●ロックマンのブロック属性オブジェクトとの接触処理修正(SW_FixRockMove_Block)
　負荷　:微増
　副作用:大
　容量　:固定バンク(0x44)
　必要　:SW_FixRockMove_Wait

　ロックマン６のブロック属性を持つオブジェクトの処理は、５までと比べるとかなり雑です。
　自機とブロック属性を持つオブジェクトが衝突した時、
　めり込み具合がX方向が大きいか、Y方向が大きいかを判断し、
　めり込み方が小さかった方に、周囲の地形などを一切読まずに、弾き出すという方式が取られています。

　このことが原因で、主に２つ気になる現象が起きます。
　一つは、ブロック属性を持つオブジェクトの横にこすりながら落下した時に、
　下端の角の部分で引っかかり、着地する事があります。
　この瞬間タイミングよくジャンプすることすら出来ます。
　もう一つは、高い所から勢い良くブロック属性を持つオブジェクトの端っこの方に着地すると
　横に弾かれそのまま転落するという現象です。
　Y速度が大きい時は、配置によっては、Y方向に一気にめり込んでしまい、
　X方向のほうが小さいめり込みだと判断されてしまうためです。

　このスイッチを有効にすると、１フレーム前の自機のY座標を記録し、
　ブロック属性を持つオブジェクトより、明らかに上/下に居た時は、必ず上/下に弾かれるように変更します。
　上の文で「雑」だなんて事を書いた割には、この対処も大概雑です。

　また、自機が落下中に下側、もしくは、自機が上昇中に上側にははじき出されないようになります。

　一方で、１フレーム前に自機とブロック属性を持つオブジェクトがY座標的に近くに居た時は
　横に弾かれるようになります。これにはかなり違和感を覚えるかもしれません。
　ウインドマンステージにある、ひっくり返る足場が、逆側に水平になる瞬間に自機を重ねておくと
　かなり不自然に、横への押し出され方をすることがわかると思います。
　周囲の地形を読まないところは変わっていないので、壁の中に押し出されることがあるのは相変わらずです。

　改造に用いる場合は、好みに合わせて有効にするか無効にするかを決めると良いと思います。
　尚、カウントボムのハンドラに少々修正が加わります。

●ロックマンの複数オブジェクトと衝突時の不具合を修正(SW_FixRockMove_Collision)
　負荷　:微増
　副作用:無
　容量　:固定バンク(0x5)[スイッチ1指定時] (0x1D)[スイッチ2指定時]
　設定値:0,1,2が設定可能

　自機と複数のオブジェクトが同時に衝突しようとすると、ちょっとした不具合が発生します。
　自機と他オブジェクトとの衝突判定は、降順に行われます。
　最初に衝突するオブジェクトは問題ないのですが、その次からのオブジェクト判定において、
　ロックマンの判定サイズが一定のルールで変化する場合があります。
　被弾判定であれば、最初の判定の時点で被弾が確定しており、無敵になるため問題ないのですが、
　ブロック属性オブジェクトが後に判定される場合は少々問題が生じます。
　多くの場合、自機の判定サイズが自機の武器のサイズ程度にまで小さくなってしまいます。
　そのため、小さくなった自機の判定がちょうど乗るくらいまで、
　自機がブロック属性オブジェクトにめり込んでしまうことがあります。
　
　この事象は、プラントマンステージの、最初の撃つと開く足場で発現することがあります。
　足場を開き、乗ると、前方からカブトムシのザコが突進してきますが、
　乗ったまま体当たりを受け止めると、ザコが貫通している間、自機が足場に少し深くめり込みます。
　そして、ザコが通り抜けると、判定サイズが正常化するので、自機が元の位置に戻ります。
　但し、上記の通り、カブトムシのほうがスロット番号の大きいオブジェクトに
　割り当てられる必要が有るため、必ず起こるとは限りません。
　
　このスイッチを有効(1,2)にすると、１つのオブジェクトと衝突後も、
　ロックマンの判定サイズが変化することが無くなります。

　また、自機の衝突判定で用いる自機の座標は、衝突判定を始めるときに記録したものを用い、
　衝突判定の途中での、ブロック属性オブジェクトに依る押し戻しを考慮しません。
　そのため、複数のブロック属性オブジェクトに深くめり込んだ場合、
　そのフレームは、その深さの補正を２回受けてしまうため、浮き上がるような挙動をすることがあります。
　この現象は、エックスステージ２の落下床の間に着地した時によく起こります。

　このスイッチを2に設定すると、衝突後に、押し戻しを考慮して判定座標を変更するようになります。
　これにより、エックスステージ２の落下床の間に着地した時の処理が「マシ」になります。
　より完全に対応するためにはこのスイッチだけでは足りません。

●ロックマンのウェイト時の処理を修正(SW_FixRockMove_Wait)
　負荷　:中増
　副作用:無？
　容量　:固定バンク(0xC～0x16)

　歩行開始時の踏み込み中、及び、アダプター装着中の着地時に腰を落としている最中は、
　その間に足元の地面が消失するなどしても動かない仕様があります。
　いずれも短時間なのであまり問題は起きませんが、
　ブリザードマンステージの潜水艦のエリアで問題を起こすことが出来ます。
　体の中心が潜水艦についていれば問題は起きないようですが、
　足先だけで地面についている場合、上記の行動を取ると、
　自機が浮き上がったり、めりこんだりする現象が起きます。
　例えば、アダプター装着中に、潜水艦が下降し始めたら足先だけで着地すると、
　浮き上がる⇔着地する　のサイクルを何回か繰り返すことになります。
　余談ですが、アダプター装着中の腰を落とすモーションは、任意のボタンを押すことでキャンセルできます。
　普段ゲームで利用しないセレクトボタンでも押し続けると、腰を落とすモーション無く着地します。

　このスイッチを有効にすると、上記の問題が起こる行動の最中でも自機の移動が起こるようになります。
　したがって、歩行開始の踏み込みで崖から踏み出すと、
　原作では短時間空中に浮いた後降下を始めますが、直ぐに降下開始するようになります。

　副作用は無しとなっていますが、実はこの動かない時間は、処理がかなり軽いため、
　タイムアタッカーがボス撃破後の処理落ち削減のために利用していることがあるようです。
　そういったことはできなくなります。

●空中歩行の修正(SW_FixRockMove_HoverJump)
　負荷　:小増
　副作用:中
　容量　:任意バンク(0x14) 固定バンク(0x2F)

　ロックマン６には、崖に向かって踏み出しても一瞬空中を歩くことができるという不思議な仕様があります。
　約３フレームの間歩くことが出来、その間にジャンプすることすら出来ます。
　水中ではより長時間、空中（？）を歩くことが出来ます。
　この仕様は、Y速度の上位バイトが01になるまで「空中」状態に移行しないため起こります。

　このスイッチを有効にすると、Y速度の下位バイトも見て、
　非ゼロになったら「空中」状態に移行するようになります。
　これにより、ロックマン５までの挙動にやや近づきます。

　副作用として、水中での落下初速が0x00.18から0x00.40に増加します。わざと増加させています。
　また、エックスステージ３の天秤リフト（？）の挙動がおかしくなったので
　プログラムを追加して誤魔化してあります。
　さらに、ブリザードマンステージの潜水艦も挙動がおかしくなったので、
　潜水艦の場所だけはこの機能が無効になるようにしました。酷い誤魔化しかた。
　言い訳をすると、空中歩行の仕様自体、
　この辺のトラブルに対応するためにやっていたのではないかとすら思っております……
　もし、改造で潜水艦の仕掛けを利用する場合は、そのステージに合わせて調整する必要があります。

　空中歩行は、不思議な仕様ですが、上手く使うとテクニックとして使える仕様でもあります。
　そのため、この仕様を修正してしまうと、ロックマン６の一つの味を殺してしまう可能性も？
　ちなみに、実はスライディングで崖を飛び降りた時も１フレームほど空中を滑ってしまうのですが、
　うまい対処法が思いつきませんでした。

●水から出るときに最大ジャンプになる不具合を修正(SW_FixRockMove_FullJumpFromWater)
　負荷　:微増
　副作用:微
　容量　:固定バンク(0xB)

　原作では起きづらいのですが、水中でジャンプして水から出ると、
　その後Aを離しても降下を始めず、最大ジャンプになってしまう不具合があります。
　この現象は、ケンタウロスマンステージの最初の、水中にある穴の上でつま先立ちして、
　Aボタンを水から出るくらい(5fほど)まで押してその後離すと、簡単に再現できます。

　このゲームは、自機のY速度の下位バイトの下位ニブルをフラグとして利用しており、
　その値がCでないと、空中でAを離しても降下を始めない仕様になっているにもかかわらず、
（この仕様自体は、バネなどのために存在する）
　水中の重力が0.18であるため、水から出た際に、問題の値がCにならないことがあるためです。

　このスイッチを有効にすると、水から出るときに、自機のY速度の下位バイトに0CをORします。
　それにより、以上の問題が起こらなくなります。

　副作用として、Y速度を書き換えるので、ほんの僅かに水から出るジャンプの軌道が変わるはずです。

●パワーロックマンとハシゴを利用した不具合を修正(SW_FixPowerShotGlitchAtLadder)
　負荷　:微増
　副作用:無
　容量　:固定バンク(0xF)

　パワーロックマンのショットを撃ち、振りかぶっている時にハシゴに掴まると色々な現象が起きます。
（１）Bを押しっぱなしで掴まる→チャージの色アニメーションが始まらない
（２）「Bを離すか、チャージを撃った後」に掴まる→弾が２発出る。しかも２発目は最大チャージ。
（３）（２）でより早く掴まる→（２）の最大チャージ弾が不発弾化する
　不発弾化した弾は、４秒強(256f)後に突然発射されます。
　不発弾を抱えている時に、次のショットを撃つと、
　不発弾が実体化し、撃とうとした弾が新しく不発弾になります。不発弾のタイマーも256fに戻ります。
　都合、１回前のショットを撃ち出すことになる、変な状態になります。

　この現象は、パワーロックマンの振りかぶり中にハシゴに掴まる事が
　十分に想定されていないために起きるようです。
　このスイッチを有効にすると、ハシゴに掴まる際に、振りかぶり中であるかどうかを判定し
　振りかぶり中には適当なプログラムに制御が渡るようにして問題が起こらないようにします。

●ゲージ処理の不具合修正(SW_FixSpriteGlitch_Gauge)
　負荷　:微減
　副作用:無
　容量　:追加無し

　画面内にスプライトが一定量存在すると、一部のオブジェクトが完全に非表示になる不具合があります。
　少な過ぎても多過ぎても起こらない不具合です。また、ゲージが多い本数表示されていると起きやすいです。
　一例として、ヤマトマンステージの中ボスの「ガマーン」が武器（爆弾orレーザー）を放ったら
　シルバートマホークを２本放つと、バグを起こすのにちょうどいいスプライト量になり、
　敵の放った武器が完全に非表示になります。

　このバグは、ゲージのセットアップ中にスプライトが足りなくなった時に起こる不具合であり、
　足りなくなったという情報が、次のゲージ処理に通知できておらず、
　先頭スプライトから再度利用を始めてしまうため起こります。

　稀なバグではありますが、起こった際に
　プレイングに影響が出る問題なので対処しておくのが良いと思います。

●歩行停止時等ジャンプ不能フレームがある仕様を修正(SW_FixNotJumpableFrame)
　負荷　:微減
　副作用:小
　容量　:固定バンク(0x0D)

　左右を離し、歩行を停止したフレームにAを押しても、ジャンプやスライディングが出ません。
　このスイッチを有効にすると、「歩行」から「棒立ち」状態に移行するフレームに、
　ジャンプやスライディングのためのAボタン押下を判定するようになります。

●武器切り替え機能の追加(SW_SwitchWeapon)
　負荷　:小増
　副作用:小
　容量　:任意バンク(0x150) 固定バンク(0x78+)

　セレクトボタンを利用した武器・アダプターの切り替え機能を追加します。
　操作方法は以下のとおりです。
　尚、+は複数同時押しを意味しますが、そのうちの一番右のボタンは最後に押して下さい。

　セレクト：順送り
　↓＋セレクト：逆送り
　セレクト＋スタート：ロックバスター装備/アダプターを外す
　↓＋セレクト＋スタート：ラッシュパワーアダプターを装着
　↑＋セレクト＋スタート：ラッシュジェットアダプターを装着

　ロックマン６はChr-RAMを利用しているので、武器のタイルパターン転送に少々時間がかかります。
　そのため、少しばかり処理が煩雑化しています。
　また、ゲームのザコ等の為のタイルパターン転送処理の機会を
　半分ほど分けてもらって処理をしているため、ものすごい勢いでセレクトを連打すると
　ザコの画像の転送に遅れが生じる場合が出てくるかもしれません。
（ただ、転送速度自体は倍になっているので、埋め合わせができている……？）

　アダプター着脱時は、より多くのタイルパターン転送の必要があるため、
　一旦、画面表示をOffにして、タイルパターンを一気に転送した後、画面表示をOnにし直しています。
　この際、画面が一瞬暗転します。
　画面表示がOffでないと、Chr-RAMにアクセス出来ないため仕方がありません。

●チャージキャンセル無効化(SW_DisableChargeCancel)
　負荷　:ほぼ不変
　副作用:微
　容量　:追加無し

　ロックマン５と６では、被弾時にバスターのチャージが無くなる仕様です。
　このスイッチを有効にすると、被弾しても
　ハイパーロックバスターとパワーロックマンのチャージが無くならなくなります。

　この、チャージのキャンセルは明らかに仕様であり、
　チャージがキャンセルされなくなると、ハイパーロックバスターが３ダメージも入ることもあり、
　ボス戦で被弾→バスターと繰り返すだけで、相手のライフを相当削れてしまう、難易度上の問題があります。
　改造で用いる場合は、方針に合わせて設定すると良いでしょう。

　副作用として、色アニメーション的にはチャージが完了していても、
　被弾時間の分チャージが足らず、不完全なチャージショットになる問題があります。
　どうにか対応しようと思ったのですが、思いの外煩雑になりそうだったのでやめておきました。

●スクロールを高速化(SW_FastScrolling)
　負荷　:ほぼ不変
　副作用:中
　容量　:固定バンク(0x10+)

　ルーム間スクロールの速度が、毎フレーム2から4へ倍加します。

　元々、この遅さは、Chr-RAMへの転送時間を稼ぐために設定されたものだと考えられます。
　したがって、そのままでは画像転送が終了せず、
　スクロール後のマップに居るザコのグラフィックが乱れてしまいます。
　そうならないために、画像の転送速度を倍加することでフォローします。

　しかし、それでも、スクロール終了までの総転送量は、原作の2/3まで低下してしまいます。
　そのため、画像の転送が間に合わない場所がいくつかあります。
　そういった箇所は、スクロールが終わった後に、転送し切るまでウェイトがかかるようになっています。

●フェードイン・アウトの高速化(SW_QuickFading)
　負荷　:不変
　副作用:微
　容量　:追加無し
　設定値:値(0-14?)が設定可能

　武器画面を開閉時などの、フェードイン・アウトの速さを指定します。
　0は原作通りの速さになります。
　1以上の値を指定する事で、フェードイン・アウトの一段階毎のフレーム数を指定できます。
　1が最速で、4が原作での値となります。

　このフェードの速さを変えてしまうと、エンディングのメドレーの切り替えタイミングがずれてしまいます。
　一応、切り替え時間を、設定された値に応じて調整するのですが、微妙にずれているかもしれません。
　なお、ケンタウロスマンに関しては、フラッシュ中の時間が考慮されないので、
　デフォルトでずれることがあります。（２回フラッシュを使うと想定されている？）

●ラッシュアダプター選択時のもたつきを修正(SW_OmitRushAdaptor)
　負荷　:不変
　副作用:微
　容量　:固定バンク(0x11+)[スイッチ2指定時]
　設定値:0,1,2が設定可能

　武器画面でラッシュアダプターを選んだ時の合体デモを簡略化します。
　原作でもスキップ出来なくはないのですが、タイミングが限られ、コツが必要でした。

　このスイッチを1に設定すると、デモが完全にカットされます。
　プレイングは円滑になりますが、当然、ゲーム中のラッシュの出番が一切なくなります。
　改造に用いることを考えると、合体デモのプログラムと画像を別のことに転用できるようになるため、
　貴重なプログラムバンク38に多くの空きが生まれ、画像の容量0x2000バイトが丸々捻出できます。

　ただ、完全にカットしてしまうのはあんまりだと思うところもあり、もう一つの案を用意しました。
　このスイッチを2に設定すると、デモがスピーディになります。以下のように変わります。
・選択時のスクロール速度が倍化、更にスクロール中にボタンを押下することでデモを中断できます。
・原作では、スクロール後に画像転送待ちのウェイトがありますが、その時間が無くなります。
・ラッシュが降下する距離が短くなり、また速くなります。（※このタイミングはボタンで中断できない）
・文字が表示される間隔が短くなります
・文字が表示されきった後のウェイトで、任意ボタンを押下することでデモを中断できます
　副作用として、文字を表示しきった後のウェイトで
　アニメーションが起こるようになります。ジェットで少々不自然。

　ちなみに、合体デモは、
　ノーマル→パワー、ノーマル→ジェット、パワー→ジェット、ジェット→パワーの４通りあります。

●瞬時回復(SW_QuickRecovering)
　負荷　:微増？
　副作用:無
　容量　:追加無し

　殆どの無印ロックマンシリーズでは、ライフ・エネルギー回復を取った時に、
　ゲーム進行が一旦完全に停止し、効果音とともにゲージが１目盛りずつ回復する仕様となっています。
　足場が不安定な場所で小さなエネルギーが出ると、
　ジャンプするタイミングをずらされてしまい危険な事にもなりがちです。

　このスイッチを有効にすると、ライフや武器エネルギーの回復を取った時に、
　効果音とともに一瞬で回復が終了するようになります。
　これにより、不意にゲームが停止するトラブルを起こさなく出来ます。

　私はこの設定が好きなのですが、
　ライフが減った時に敵が落とした大ライフエネルギーで、ちゃらららららららっと回復するのも
　なかなか小気味良いものだと思っています。
　改造に用いる場合は、演出を取るかプレイアビリティを取るかで有効にするか決めるのが良いと思います。

●トゲをダメージ化(SW_NerfedSpike)
　負荷　:微増
　副作用:中
　容量　:固定バンク(0x1D)
　設定値:ダメージの値を設定可能

　このスイッチに値を設定すると、即死トゲがその値の分のダメージに変わります。
　改造を作る人で、即死トラップが嫌いだが、ダメージエリアは欲しいという
　極めてレアな条件下でのみ、日の目を見るでしょう。
　副作用として、ナイトマンステージの吊り天井等に仕込んだトゲにて、挙動が少々怪しくなります。

●空中上昇中にAを離した時ふわりと降下へ移行(SW_SmoothAirBrake)
　負荷　:微増
　副作用:中
　容量　:任意バンク(0x15程度) 固定バンク(0x07)
　設定値:程度を指定可能

　ロックマン６はジャンプ等で空中で上昇中にAを離すと、急にポトリと転落し始めます。
　これは、その処理のY速度設定時に、整数部に00を書き込むだけで、小数部がそのままになっていることが原因の一つです。
　この仕様のため、設定されるY速度が、毎回、微妙に異なるという問題も生じています。

　この項目を有効にすると、小数部にも書き込みを行うようになり、転落開始の速度が固定され、程度が軽くなります。
　更に、設定によっては、上方向への速度を若干残す様になります。
　1に指定すると、概ね、ロックマン４・５の様な落ち方になります。(Vy<0の時、Vy=00.0Cに設定される)
　2に指定すると、概ね、ロックマン２の様な落ち方になります。(Vy<-1の時、Vy=FF.0Cに設定される)
　3以上にも指定できますが、ジャンプ力の調整が効きづらくなります。

　ジェットロックマンのジェットの使用を中止したときにも、滑らかに落ち始めるようになります。
　水中だと影響が大きく出る一方、上昇気流や丸いバネには影響がないはずです。

●チャージバスター発射音の修正(SW_FixChargeBusterSE)
　負荷　:不変
　副作用:微
　容量　:追加無し

　ロックマン６は何故かハイパーロックバスターのチャージショットの効果音がチャージ無しと同じです。
　もう少し正確に言うと、鳴らそうとしているにも関わらず、
　チャージ無しバスターの効果音で上書きされてしまっています。

　このスイッチを有効にすると、サウンドデータを書き換え、
　チャージショットの効果音の優先度を上げる事で、チャージショットの効果音が鳴るようになります。
　ついでに、反射音の優先度も上げて、チャージショットが反射された時にも音が鳴るようになります。
　中チャージでもチャージショット音が鳴るように設定されているのですが、
　個人的な好みから、チャージ無しバスターと同じ音に変更してあります。

　改造に使う場合は、既に書き換えられたサウンドデータに、この設定で上書きしようとすると、
　データがずれているため、大変ややこしいことになります。ご注意を。

　余談ですが、ロックマン６の効果音発音のプログラムは何故か雑で、変数に効果音番号を書き込んでおくと、
　そのフレームの最後にその変数を読み、その番号の効果音を鳴らすという方法が主に利用されています。
　これだと、効果音優先度も何も関係なく、
　そのフレームで最後に鳴らされようとされた音が発音されることになってしまいます。
　しかも、それが実際に鳴るかどうかは、その段階でなっていた効果音の優先度と比較することになり
　効果音優先度を使いたいんだか使いたくないんだかよくわからない状態になっています。

　一応、変数方式とは別に、５以前と同様に、
　効果音キューに鳴らしたい効果音を追加していくサブルーチンもあるのですが
　何故か一部の場所でしか利用されていません。チャージショットの発音にはこれが利用されています。

　以上の仕様により、本来聴けなそうなチャージショットの効果音を聴けることが知られています。
　ロックマンが着地するフレームにチャージショットを撃つと、チャージショットの効果音が鳴ります。

　原作での効果音優先度は[豆:7][チャージ:7][着地音:6]です。
　チャージを撃つ時は、変数方式に豆音、キュー方式にチャージ音が、同一フレームで発音されます。
　変数方式であっても、そのフレームの最後に、その音番号をキューに追加するという方式になっているため、
　最終的に、キューには、「チャージ音」「豆音」の順番に収まります。
　これらの音番号を順番に指定して、サウンドドライバの発音ルーチンが呼び出されます。
　どちらも同じ優先度7であるので、後発の「豆音」が優先され、そちらが鳴ることになります。

　これに着地が挟まると、変数方式に豆音が入った後、着地音に上書きされます。（優先度は低いのに）
　この時の最終的なキューは、「チャージ音」「着地音」になります。
　チャージ音の方が優先度が高いので、着地音の処理はスキップされ、チャージ音が鳴るわけです。

　何この要らない長いうんちく。

●落下床のサイズを変更(SW_ModifyFallingBlockSize)
　負荷　:不変
　副作用:無
　容量　:追加無し

　半分以上、私の趣味による設定です。
　エックスステージ２にある落下床に乗ると、そもそも１ドット上昇するのが気に入らなかったので
　落下床のサイズを縦に１ドット小さくすることで、浮かないようにしました。
　しかし、実際にスムースに進めるようになるためには、このスイッチの他に
　SW_FixRockMove_Block/SW_FixRockMove_Collision=2/SW_FixRockMove_Wait
　が必要になり、また、スライディングでも円滑に進むには、更に、
　SW_FixRockMove_Sliding
　が必要になるようです。

■■■■■■■■テスト用■■■■■■■■
●ラッシュアダプターを常時所持(SW_DebugAlwaysHaveAdaptor)
　負荷　:ほぼ不変
　副作用:無
　容量　:任意バンク(0x2)

　このスイッチを有効にすると、アダプター２種が最初から使えるようになります。
　この最適化を作るときに使ったデバッグ用の機能です。一応、使えなくはないです。

●ステージ読み込み時に未使用の部分を00で埋める(SW_Debug00FillAtLoadingStage)
　負荷　:増
　副作用:無
　容量　:任意バンク(0x36)

　SW_OptimizeTerrain2のマップロード時に、マップデータ全体を00クリアするようになります。
　そのため、読み込み処理の負荷が増大します。
　テスト用の機能で、意味が無いので、基本的には使わないで下さい。
　SW_OptimizeTerrain2のルーム情報を作成する時に、ミスにすぐ気づけるため、一応便利な事も。
　というか、それを作るために付けた機能なのですが。

●テスト用マップを読み込み(SW_DebugTestMap)
　デバッグ時にデバッグ用マップをロードするときに使っていたスイッチです。
　全く意味が無いので使わないで下さい。

●画像転送が遅くなる時アセンブルを失敗させる(SW_DebugWarnSlowTransfer)
　とても説明が面倒なスイッチです。その上、読んでも得るものがありません。
　結論だけを先に書くと、このスイッチを有効にする必要はありません。

　画像転送ルーチンは、速度にシビアなことがあります。
　それは、vblank中に処理を終えなければならないためです。
　nesのプロセッサは、その仕様上、プログラムの配置によって分岐命令の実行速度が変化します。
　もし、速い配置の時は正常でも、遅い配置になるとvblank中に処理を終えられない、
　ということがあっては大変です。
　そのため、制作中は、遅い配置になるとアセンブルを失敗するようにしていました。

　……蓋を開けてみれば、遅い配置になっても、vblank中に十分に処理を完了できることがわかりました。
　しかし、製作中は、更にプログラムが変更されるかもしれません。
　そうなった時に問題を起こさないかはわかりません。
　そのため、遅い配置になるとアセンブルを失敗させるような記述を削除するわけにはいきませんでした。

　配布するソースを準備する段階になって、スイッチの組み合わせによっては、
　画像転送ルーチンが遅い配置になり得、それによりアセンブルに失敗する可能性に気付きました。
　しかし、意図がありアセンブルを失敗させる記述を削除するのは忍びないものです。
　そこで、このスイッチを設けて、このスイッチが有効の時のみ、
　アセンブルを失敗させる記述を有効化することにしました。

　……と、いうことで、このスイッチを有効にしても全く意味がありません！
　一応、このスイッチを有効化して、アセンブル。
　もし、エラーが出た時は、src/src/pool.asmの、"src/misc_s_xfer.asm"をincludeしている場所を
　微妙に上下に動かせば、画像転送ルーチンを速い配置にすることが出来ます。
　しかし、プログラムをあちこち動かすということは、
　その分、また別のコードは遅い配置になってしまうかもしれないので
　結局、気にするだけ無駄だと思います。
